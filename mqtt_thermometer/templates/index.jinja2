{% extends "base.jinja2" %}

{% block title %}{{ application_name }}{% endblock %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://unpkg.com/htmx.org@1.9.6"></script>
<script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://unpkg.com/htmx.org@1.9.11/dist/ext/ws.js"></script>
{% endblock %}

{% block content %}
<div id="legends"></div>

<div class="chart-container" hx-trigger="load, every 60s" hx-get="temperatures" hx-swap="none" hx-ext="Chartjs"
    style="position: relative; height: 85vh; width: 95vw;">
    <canvas id="chart"></canvas>
</div>

<script>
    // Determine if we're on mobile
    const isMobile = window.matchMedia("(max-width: 767px)").matches;

    // Adjust chart defaults for mobile
    if (isMobile) {
        Chart.defaults.font.size = 10;  // Smaller font for mobile
    } else {
        Chart.defaults.font.size = 24;  // Original font size for desktop
    }

    const chart = new Chart(
        document.getElementById('chart'),
        {
            type: 'line',
            data: {},
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        position: 'right',
                        ticks: {
                            stepSize: 1, // Force tick marks every 1°C
                            callback: function (value, index, values) {
                                // Only show labels for values divisible by 5
                                if (value % 5 === 0) {
                                    return value + ' °C';
                                }
                                return ''; // Return empty string for other values to hide the label
                            },
                            color: 'rgba(255, 255, 255, 1)',
                            maxTicksLimit: undefined,
                            // Force Chart.js to generate ticks at every degree
                            autoSkip: false
                        },
                        grid: {
                            color: function (context) {
                                if (context.tick.value % 10 === 0) {
                                    return 'rgba(255, 255, 255, 1)'; // Major grid lines every 10°C (white)
                                } else if (context.tick.value % 5 === 0) {
                                    return 'rgba(128, 128, 128, 0.8)'; // Minor grid lines every 5°C (grey)
                                }
                                return 'rgba(0, 0, 0, 0)'; // Transparent - hide 1°C grid lines in chart area
                            },
                            // Show tick marks on the axis itself (right side)
                            drawTicks: true,
                            tickColor: 'rgba(255, 255, 255, 0.8)', // White color for all tick marks
                            tickLength: 4 // Small tick marks for 1°C intervals
                        }
                    },
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'H'
                            }
                        },
                        ticks: {
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 24,
                            color: 'rgba(255, 255, 255, 1)'
                        },
                        grid: {
                            color: function (context) {
                                if (new Date(context.tick.value).getHours() % 12 === 0) {
                                    return 'rgba(255, 255, 255, 1)';
                                }
                                if (new Date(context.tick.value).getHours() % 3 === 0) {
                                    return 'rgba(255, 255, 255, 0.5)';
                                }
                                return 'rgba(255, 255, 255, 0.2)';
                            }
                        }
                    }
                },
                elements: {
                    point: {
                        radius: 0
                    },
                    line: {
                        borderWidth: isMobile ? 2 : 3
                    }
                },
                animation: {
                    duration: 0
                },
                plugins: {
                    legend: {
                        display: false
                    }
                },
                layout: {
                    padding: isMobile ? 0 : 8 // Reduce padding on mobile
                }
            }
        }
    );

    // Handle screen orientation changes
    window.addEventListener('resize', function () {
        const newIsMobile = window.matchMedia("(max-width: 767px)").matches;
        if (newIsMobile !== isMobile) {
            location.reload();
        }
    });

    // WebSocket connection for real-time updates
    const ws = new WebSocket(`ws://${window.location.host}/ws`);

    ws.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);

            if (data.type === 'legends') {
                // Update only legends
                console.log('Websocket: Legends-only update received');
                document.getElementById('legends').innerHTML = data.legends;
            } else if (data.type === 'combined') {
                // Update both legends and chart
                console.log('Websocket: Combined legends + chart update received');
                document.getElementById('legends').innerHTML = data.legends;

                // Convert chart data format for Chart.js
                const convertedChartData = {
                    datasets: data.chart.datasets.map(dataset => ({
                        ...dataset,
                        data: Object.entries(dataset.data).map(([timestamp, value]) => ({
                            x: timestamp,
                            y: value
                        }))
                    }))
                };

                chart.data = convertedChartData;
                chart.update('none'); // Update without animation for real-time feel
                chart.resize(); // Force redraw to ensure visibility
                console.log('Chart updated with new data, datasets:', convertedChartData.datasets.length);
            }
        } catch (error) {
            console.log('Non-JSON websocket message received, treating as legacy legends update');
            // Fallback for legacy legend-only updates
            document.getElementById('legends').innerHTML = event.data;
        }
    };

    ws.onopen = function (event) {
        console.log('WebSocket connected');
    };

    ws.onclose = function (event) {
        console.log('WebSocket disconnected, attempting to reconnect...');
        setTimeout(() => {
            location.reload(); // Reload page to reconnect
        }, 1000);
    };

    htmx.defineExtension('Chartjs', {
        transformResponse: function (text, xhr, elt) {
            var data = JSON.parse(text);

            // Convert chart data format for Chart.js (from /temperatures endpoint)
            const convertedChartData = {
                datasets: data.datasets.map(dataset => ({
                    ...dataset,
                    data: Object.entries(dataset.data).map(([timestamp, value]) => ({
                        x: timestamp,
                        y: value
                    }))
                }))
            };

            var ctx = document.getElementById('chart').getContext('2d');
            chart.data = convertedChartData;
            chart.update();
            return "";
        }
    });
</script>
{% endblock %}
