{% extends "base.jinja2" %}

{% block title %}{{ application_name }}{% endblock %}

{% block head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://unpkg.com/htmx.org@1.9.6"></script>
<script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<script src="https://unpkg.com/htmx.org@1.9.11/dist/ext/ws.js"></script>
{% endblock %}

{% block content %}
<div id="legends"></div>

<div class="chart-container" hx-trigger="load, every 60s" hx-get="temperatures" hx-swap="none" hx-ext="Chartjs"
    style="position: relative; height: 85vh; width: 100vw;">
    <canvas id="chart"></canvas>
</div>

<script>
    // Determine if we're on mobile
    const isMobile = window.matchMedia("(max-width: 767px)").matches;

    // Adjust chart defaults for mobile
    if (isMobile) {
        Chart.defaults.font.size = 10;  // Smaller font for mobile
    } else {
        Chart.defaults.font.size = 24;  // Original font size for desktop
    }

    // Temperature color mapping function
    function getTemperatureColor(temp) {
        // Color mapping based on temperature ranges
        if (temp >= 30) return '#8B0000'; // Dark red (very hot)
        if (temp >= 25) return '#FF4500'; // Orange red (hot)
        if (temp >= 20) return '#FF8C00'; // Dark orange (warm)
        if (temp >= 15) return '#FFD700'; // Gold (neutral-warm)
        if (temp >= 10) return '#ADFF2F'; // Green yellow (cool)
        if (temp >= 5) return '#00FF7F'; // Spring green (cold)
        if (temp >= 0) return '#00CED1'; // Dark turquoise (coldish)
        if (temp >= -10) return '#4169E1'; // Royal blue (cold)
        if (temp >= -20) return '#0000CD'; // Medium blue (very cold)
        return '#191970'; // Midnight blue (extremely cold)
    }

    // Heat map plugin
    const heatMapPlugin = {
        id: 'heatMap',
        afterDraw: function (chart) {
            const ctx = chart.ctx;
            const chartArea = chart.chartArea;
            const yAxis = chart.scales.y;

            // Save the current context state
            ctx.save();

            // Heat map bar configuration
            const barWidth = isMobile ? 15 : 20;
            const barX = chartArea.right + (isMobile ? 55 : 85); // Position even further to the right of the chart

            // Draw heat map bar
            const minTemp = yAxis.min;
            const maxTemp = yAxis.max;
            const tempRange = maxTemp - minTemp;
            const barHeight = chartArea.bottom - chartArea.top;

            // Draw temperature gradient bar
            for (let i = 0; i <= tempRange; i += 0.5) {
                const temp = minTemp + i;
                const y = yAxis.getPixelForValue(temp);
                const segmentHeight = barHeight / (tempRange / 0.5);

                ctx.fillStyle = getTemperatureColor(temp);
                ctx.fillRect(barX, y - segmentHeight / 2, barWidth, segmentHeight + 1);
            }

            // Remove the border around heat map to see if that's causing the lines
            // ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            // ctx.lineWidth = 1;
            // ctx.strokeRect(barX, chartArea.top, barWidth, barHeight);

            // Restore the context state
            ctx.restore();
        }
    };

    const chart = new Chart(
        document.getElementById('chart'),
        {
            type: 'line',
            data: {},
            options: {
                responsive: true,
                maintainAspectRatio: false,
                // Disable chart border to prevent lines over heat map
                borderColor: 'transparent',
                backgroundColor: 'transparent',
                scales: {
                    y: {
                        beginAtZero: true,
                        position: 'right',
                        ticks: {
                            stepSize: 1, // Force tick marks every 1°C
                            callback: function (value, index, values) {
                                // Only show labels for values divisible by 5
                                if (value % 5 === 0) {
                                    return value + ' °C';
                                }
                                return ''; // Return empty string for other values to hide the label
                            },
                            color: 'rgba(255, 255, 255, 1)',
                            maxTicksLimit: undefined,
                            // Force Chart.js to generate ticks at every degree
                            autoSkip: false
                        },
                        grid: {
                            color: function (context) {
                                if (context.tick.value % 10 === 0) {
                                    return 'rgba(255, 255, 255, 1)'; // Major grid lines every 10°C (white)
                                } else if (context.tick.value % 5 === 0) {
                                    return 'rgba(128, 128, 128, 0.8)'; // Minor grid lines every 5°C (grey)
                                }
                                return 'rgba(0, 0, 0, 0)'; // Transparent - hide 1°C grid lines in chart area
                            },
                            // Show tick marks on the axis itself (right side)
                            drawTicks: true,
                            tickColor: 'rgba(255, 255, 255, 0.8)', // White color for all tick marks
                            tickLength: 4, // Small tick marks for 1°C intervals
                            // Prevent grid lines from extending beyond chart area
                            drawBorder: false,
                            offset: false
                        }
                    },
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour',
                            displayFormats: {
                                hour: 'H'
                            }
                        },
                        ticks: {
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 24,
                            color: 'rgba(255, 255, 255, 1)'
                        },
                        grid: {
                            color: function (context) {
                                if (new Date(context.tick.value).getHours() % 12 === 0) {
                                    return 'rgba(255, 255, 255, 1)';
                                }
                                if (new Date(context.tick.value).getHours() % 3 === 0) {
                                    return 'rgba(255, 255, 255, 0.5)';
                                }
                                return 'rgba(255, 255, 255, 0.2)';
                            }
                        }
                    }
                },
                animation: {
                    duration: 0
                },
                plugins: {
                    legend: {
                        display: false
                    }
                },
                // Additional border settings to prevent chart borders
                interaction: {
                    intersect: false
                },
                elements: {
                    point: {
                        radius: 0,
                        borderWidth: 0
                    },
                    line: {
                        borderWidth: isMobile ? 2 : 3
                    }
                },
                layout: {
                    padding: {
                        top: isMobile ? 0 : 8,
                        right: isMobile ? 60 : 80, // Add extra padding for heat map
                        bottom: isMobile ? 0 : 8,
                        left: isMobile ? 0 : 8
                    }
                }
            },
            plugins: [heatMapPlugin] // Register the heat map plugin
        }
    );

    // Handle screen orientation changes
    window.addEventListener('resize', function () {
        const newIsMobile = window.matchMedia("(max-width: 767px)").matches;
        if (newIsMobile !== isMobile) {
            location.reload();
        }
    });

    // WebSocket connection for real-time updates
    const ws = new WebSocket(`ws://${window.location.host}/ws`);

    ws.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);

            if (data.type === 'legends') {
                // Update only legends
                console.log('Websocket: Legends-only update received');
                document.getElementById('legends').innerHTML = data.legends;
            } else if (data.type === 'combined') {
                // Update both legends and chart
                console.log('Websocket: Combined legends + chart update received');
                document.getElementById('legends').innerHTML = data.legends;

                // Convert chart data format for Chart.js
                const convertedChartData = {
                    datasets: data.chart.datasets.map(dataset => ({
                        ...dataset,
                        data: Object.entries(dataset.data).map(([timestamp, value]) => ({
                            x: timestamp,
                            y: value
                        }))
                    }))
                };

                chart.data = convertedChartData;
                chart.update('none'); // Update without animation for real-time feel
                chart.resize(); // Force redraw to ensure visibility
                console.log('Chart updated with new data, datasets:', convertedChartData.datasets.length);
            }
        } catch (error) {
            console.log('Non-JSON websocket message received, treating as legacy legends update');
            // Fallback for legacy legend-only updates
            document.getElementById('legends').innerHTML = event.data;
        }
    };

    ws.onopen = function (event) {
        console.log('WebSocket connected');
    };

    ws.onclose = function (event) {
        console.log('WebSocket disconnected, attempting to reconnect...');
        setTimeout(() => {
            location.reload(); // Reload page to reconnect
        }, 1000);
    };

    htmx.defineExtension('Chartjs', {
        transformResponse: function (text, xhr, elt) {
            var data = JSON.parse(text);

            // Convert chart data format for Chart.js (from /temperatures endpoint)
            const convertedChartData = {
                datasets: data.datasets.map(dataset => ({
                    ...dataset,
                    data: Object.entries(dataset.data).map(([timestamp, value]) => ({
                        x: timestamp,
                        y: value
                    }))
                }))
            };

            var ctx = document.getElementById('chart').getContext('2d');
            chart.data = convertedChartData;
            chart.update();
            return "";
        }
    });
</script>
{% endblock %}
